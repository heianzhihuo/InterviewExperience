这里简单介绍各种数据结构

# 线性结构
线性结构是数据结构里最简单的类型，其特点是任何一个节点最多只有一个后继节点，也最多只有一个前驱节点

## Queue

队列是一种线性的数据结构，其特点是FIFO，先进先出，尾部进队，头部出队

### 队列的种类
- 单向链表
- 单向循环链表
- 双向链表
- 双向循环链表
- 数组

## 数组和链表

### 数组
- 是一种线性数据结构
- 数组中的元素在物理上连续
- 支持随机访问，即可以直接通过下标找到某个元素
- 在数组中间插入和删除元素时需要移动元素，效率低 

### 链表
- 线性数据结构
- 链表中的元素在物理上可以不连续
- 在链表中间插入和删除元素不需要移动元素，是O(1)时间的
- 顺序访问，不能直接通过下标找到某个元素，为了找到某个下标的元素，必须从链表头部依次遍历各个元素

## 栈

栈是一种重要的数据结构，其特点是LIFO，先进后出，顶部进栈，顶部出栈

### 栈的实现
- 数组实现
- 链表实现：用链表实现栈在链表头部插入，链表头部删除

# Set,集合结构
集合结构中的元素的特点是不重复且无序的集合。在Java中主要有HashSet和TreeSet两大类实现，在判断重复时，会调用hashCode和equal()方法实现。

## HashSet
HashSet本质是哈希结构，数组+链表，通过计算插入元素的hashCode来获取元素在集合中的元素
## TreeSet
TreeSet是红黑树结构，每个元素都是树中的一个节点，插入的元素都会进行排序

# 树型结构
树型结构的特点是任何一个节点只有一个前驱节点，可以有多个后继节点

## 二叉树

二叉树：任何一个节点最多有两个后继节点。二叉树是树型结构中最重要的树

### 1 完全二叉树
若二叉树的高度为h，除第h层外，其它各层(1~h-1)的节点数都达到最大个数，第h层的有叶子节点，且所有叶子节点都是从左到右依次排布

### 2 满二叉树
除了叶子节点外，每个节点都左右儿子，且叶子节点都在最底层，即每层的节点数都达到最大值

### 3 二叉搜索树(BST)
又称二叉排序树，二叉查找树，Binary Search Tree ，其特点是根节点的值大于其左子树上所有节点的值，小于其右子树上所有节点的值，且左右子树均为二叉搜索树

### 4 堆
堆是一种重要的数据结构，堆是是一棵完全二叉树：每个节点的值都大于等于其左右孩子节点的值，称为最大堆；每个节点的值都小于等于其左右孩子节点的值，称为最小堆
- 堆一般用数组实现
- 堆顶是节点0
- 节点i的左右子树分别是(i+1)*2-1和(i+1)*2
- 节点i的父节点是(i-1)/2
- 插入元素，直接插入到数组最末尾，从下往上调整堆，时间复杂度O(h)
- 删除元素，堆顶元素和堆末尾元素交换，删除堆尾元素，从上往下调整堆，时间复杂度O(h)

### 4 平衡二叉树
又称为AVL树，它是一棵二叉排序树，它的左右两个子树的高度差不超过1，且左右两个子树都是平衡二叉树

### 5 红黑树
红黑树是应用非常广泛的一种二叉排序树
- 红黑树的特点
	1. 每个节点非黑即红
	2. 根节点是黑色的
	3. 每个叶子节点都是黑色的空节点(NIL节点)
	4. 如果一个节点是红色的，那么它的子节点必须是黑色的
	5. 从根节点到叶子节点的每条路径上，必须包含相同数目的黑色节点（即具有相同的黑高）
- 红黑树的时间复杂度为O(logn)，一棵含有n个节点的红黑树高度至多为2log(n+1)
- 红黑树的基本操作
	- 左旋
	- 右旋
	- 插入元素，先查找，然后将节点插入，节点着色为红色，最后通过旋转和重新着色的方法来修正该树
	- 删除元素同理，先查找，然后删除节点，最后通过旋转和重新着色来调整该树
- 红黑树的应用
	- Java中的TreeSet和TreeMap
	- C++ STL中的set、map
	- Linux虚拟内存的管理

### 6 B树，B+树，B*树

### 7 LSM树

# 图型结构

图型数据结构是一种多对多的数据结构

## 有向图

## 无向图

## 图的相关算法

# 其它

## 跳表
跳表全称叫做跳跃表，是一个随机化的数据机构，实质是一种可以进行二分查找的有序链表，也可以看作是二叉树的变种。其原理非常简单，本质是多层链表。

- 跳表处理的是有序的链表，在有序的链表中，如果要查找某个数，只能从头到尾比较每个元素是否匹配，直到找到匹配的数为止
- 为了提高搜索速度，把链表中的一些节点提取出来，作为一级索引
- 在一级索引的基础上，还可以再提取一些节点作为二级索引，同理可以产生多级索引，形成多层链表形式
- 跳表的性质
	- 由很多层链表组成
	- 每一层都是有序链表
	- 最底层（Level 1）的链表包含所有元素
	- 如果一个元素在Level i中出现，那么它在Level i以下的链表都会出现
	- 每个节点包含两个指针，一个指向同一层链表的下一个元素，一个指向下一层的元素
- 跳表的查找：从最高层的链表开始查找，找到所在为位置，然后往下层查找
- 跳表的插入，先决定插入元素占用的层数，然后对应层开始查找对应插入的位置
- 跳表的删除，在各层中找到包含x的节点，直接通过delete方法删除对应节点
- 层数的决定算法：做一次丢硬币实验，如果遇到正面则继续丢，遇到反面则停止。


