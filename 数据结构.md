这里简单介绍各种数据结构

# 线性结构
线性结构是数据结构里最简单的类型，其特点是任何一个节点最多只有一个后继节点，也最多只有一个前驱节点

## Queue

队列是一种线性的数据结构，其特点是FIFO，先进先出，尾部进队，头部出队

### 队列的种类
- 单向链表
- 单向循环链表
- 双向链表
- 双向循环链表
- 数组

## 数组和链表

### 数组
- 是一种线性数据结构
- 数组中的元素在物理上连续
- 支持随机访问，即可以直接通过下标找到某个元素
- 在数组中间插入和删除元素时需要移动元素，效率低 

### 链表
- 线性数据结构
- 链表中的元素在物理上可以不连续
- 在链表中间插入和删除元素不需要移动元素，是O(1)时间的
- 顺序访问，不能直接通过下标找到某个元素，为了找到某个下标的元素，必须从链表头部依次遍历各个元素

## 栈

栈是一种重要的数据结构，其特点是LIFO，先进后出，顶部进栈，顶部出栈

### 栈的实现
- 数组实现
- 链表实现：用链表实现栈在链表头部插入，链表头部删除

# Set,集合结构
集合结构中的元素的特点是不重复且无序的集合。在Java中主要有HashSet和TreeSet两大类实现，在判断重复时，会调用hashCode和equal()方法实现。

## HashSet
HashSet本质是哈希结构，数组+链表，通过计算插入元素的hashCode来获取元素在集合中的元素
## TreeSet
TreeSet是红黑树结构，每个元素都是树中的一个节点，插入的元素都会进行排序

# 树型结构
树型结构的特点是任何一个节点只有一个前驱节点，可以有多个后继节点

## 二叉树

二叉树：任何一个节点最多有两个后继节点。二叉树是树型结构中最重要的树

### 1 完全二叉树
若二叉树的高度为h，除第h层外，其它各层(1~h-1)的节点数都达到最大个数，第h层的有叶子节点，且所有叶子节点都是从左到右依次排布

### 2 满二叉树
除了叶子节点外，每个节点都左右儿子，且叶子节点都在最底层，即每层的节点数都达到最大值

### 3 二叉搜索树(BST)
又称二叉排序树，二叉查找树，Binary Search Tree ，其特点是根节点的值大于其左子树上所有节点的值，小于其右子树上所有节点的值，且左右子树均为二叉搜索树

### 4 堆
堆是一种重要的数据结构，堆是是一棵完全二叉树：每个节点的值都大于等于其左右孩子节点的值，称为最大堆；每个节点的值都小于等于其左右孩子节点的值，称为最小堆
- 堆一般用数组实现
- 堆顶是节点0
- 节点i的左右子树分别是(i+1)*2-1和(i+1)*2
- 节点i的父节点是(i-1)/2
- 插入元素，直接插入到数组最末尾，从下往上调整堆，时间复杂度O(h)
- 删除元素，堆顶元素和堆末尾元素交换，删除堆尾元素，从上往下调整堆，时间复杂度O(h)

### 4 平衡二叉树
又称为AVL树，它是一棵二叉排序树，它的左右两个子树的高度差不超过1，且左右两个子树都是平衡二叉树

### 5 红黑树
红黑树是应用非常广泛的一种二叉排序树
- 红黑树的特点
	1. 每个节点非黑即红
	2. 根节点是黑色的
	3. 每个叶子节点都是黑色的空节点(NIL节点)
	4. 如果一个节点是红色的，那么它的子节点必须是黑色的
	5. 从根节点到叶子节点的每条路径上，必须包含相同数目的黑色节点（即具有相同的黑高）
- 红黑树的时间复杂度为O(logn)，一棵含有n个节点的红黑树高度至多为2log(n+1)
- 红黑树的基本操作
	- 左旋
	- 右旋
	- 插入元素，先查找，然后将节点插入，节点着色为红色，最后通过旋转和重新着色的方法来修正该树
	- 删除元素同理，先查找，然后删除节点，最后通过旋转和重新着色来调整该树
- 红黑树的应用
	- Java中的TreeSet和TreeMap
	- C++ STL中的set、map
	- Linux虚拟内存的管理

### 6 B树，B+树，B*树
1. B树：多路搜索树
	- 任意给定叶子节点最多M个儿子
	- 根节点儿子节点数为[2,M]
	- 除根节点外，非叶子节点的儿子数为[M/2,M]
	- 每个节点至少存放M/2-1向上取整和至多M-1个关键字
	- 所有叶子节点位于同一层
	- **关键字分布在整棵树中**
	- **搜索可能在非叶子节点结束**

2. B+树：B树的变体
	- 非叶子节点的子树指针于关键字个数相同
	- **所有关键字都在叶子节点中出现**，稠密索引
	- **叶子节点形成了一个链表，链表中的关键字是有序的**
	- **搜素必须达到叶子节点**
	- B+树更适合操作系统的文件索引和数据库索引

**原因：1）B+树的磁盘读写代价更低，B+tree的内部节点没有指向关键字具体信息的指针，其内部节点相对B树更小，从而盘块可以容纳更多的关键字，一次性读入内存中的关键字数也越多。2）B+树的查询效率更稳定，由于任何关键字的查找必须走一条从根节点到叶子节点的路径，所有关键字的查找长度相同，导致每个关键字查找效率相同。3）数据库采用B+树的另一个原因是，B+树只需要遍历叶子节点就可以实现整棵树的遍历，而在数据库中，基于范围的查询非常频繁，而B树不支持范围或者效率太低。

3. B*树：是B+树的变体
	- 在B+树的基础上，非根节点和非叶子节点增加了指向兄弟的指针；
	- 在分裂时，如果它的下一个兄弟节点未满，则将一部分数据移到兄弟节点，再插入关键字。如果兄弟节点也满了，则再原节点和兄弟节点之间增加新节点，并各复制1/3的数据到新节点。
	- **B*树分配新节点的概率比B+树要低，空间使用率更高**

### 7 SkipList(跳表)
跳表的全称是跳跃表，是一个随机化的数据结构，实质是可以进行二分查找的有序链表，也可以看作是二叉树的变种。其本质是多层有序链表

- 跳表处理的是有序链表，在有序链表中的查找只有遍历搜索
- 为了提高搜索速度，把链表中的一些节点提取出来作为一级索引；在一级索引的基础上，还可以再提取一些节点作为二级索引，同理可以产生多级索引，形成多层链表形式
- 跳表的性质	
	- 由多层链表组成
	- 每层都是有序链表
	- 最底层（Level 1）的链表包含所有元素
	- 如果一个元素在Level i中出现，那么它在Level i以下的链表都会出现
	- 每个节点包含两个指针，一个指向同一层链表的下一个元素，一个指向下一层的元素
- 跳表的查找：从最高层的链表开始查找，找到所在为位置，然后在下层查找
- 跳表的插入，先决定插入元素占用的层数，然后在对应层开始查找对应插入的位置
- 跳表的删除，在各层中找到包含x的节点，直接通过delete方法删除对应节点
- 层数的决定算法：做一次丢硬币实验，如果遇到正面则继续丢，遇到反面则停止
- 跳表的性能：跳表的插入查询和删除的时间都和跳表层数相关，因此跳表的时间复杂度是O(logn),空间复杂度是O(n)，与红黑树和平衡二叉树接近

### 跳表与红黑树的比较
在Redis中选择使用跳表实现有序集合，这是为什么？
有序集合支持的操作：
	- 插入元素
	- 删除元素
	- 查找元素
	- 有序输出所有元素
	- 查找区间内的所有元素
红黑树能够很好的完成前四项，且时间复杂度与跳表一致。但是在区间查找中，红黑树的效率不如跳表。
在跳表中，要查找区间的元素，只要定位到两个区间端点在最低层的位置，然后按顺序遍历元素就可以了，非常高效。
而在红黑树中，只能定位到端点后，再从首位置开始，每次查找后继节点，相对的时间效率不如跳表。
除此之外，跳表的思想非常简单，实现起来很容易。


### 8 LSM树

# 图型结构

图型数据结构是一种多对多的数据结构

## 有向图

## 无向图

## 图的相关算法

# 其它

## 跳表
跳表全称叫做跳跃表，是一个随机化的数据机构，实质是一种可以进行二分查找的有序链表，也可以看作是二叉树的变种。其原理非常简单，本质是多层链表。

- 跳表处理的是有序的链表，在有序的链表中，如果要查找某个数，只能从头到尾比较每个元素是否匹配，直到找到匹配的数为止
- 为了提高搜索速度，把链表中的一些节点提取出来，作为一级索引
- 在一级索引的基础上，还可以再提取一些节点作为二级索引，同理可以产生多级索引，形成多层链表形式
- 跳表的性质
	- 由很多层链表组成
	- 每一层都是有序链表
	- 最底层（Level 1）的链表包含所有元素
	- 如果一个元素在Level i中出现，那么它在Level i以下的链表都会出现
	- 每个节点包含两个指针，一个指向同一层链表的下一个元素，一个指向下一层的元素
- 跳表的查找：从最高层的链表开始查找，找到所在为位置，然后往下层查找
- 跳表的插入，先决定插入元素占用的层数，然后对应层开始查找对应插入的位置
- 跳表的删除，在各层中找到包含x的节点，直接通过delete方法删除对应节点
- 层数的决定算法：做一次丢硬币实验，如果遇到正面则继续丢，遇到反面则停止。


