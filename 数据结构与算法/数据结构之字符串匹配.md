# 数据结构之字符串匹配

在刷LeetCode的时候发现了很多关于字符串的问题，其中字符串匹配是字符串中最经典的问题，因此这里对字符串匹配的相关算法做一个总结。提到字符串匹配最先想到的是KMP算法，KMP算法在理论上是最优的算法。实际上有很多不同的字符串匹配算法，下面的表格中列出了四种不同的字符串匹配算法及其时间复杂度。

算法|预处理时间|匹配时间
:---:|:--:|:---:
暴力匹配法|$O(1)$|$O((n-m+1)m)$
Rabin-Karp|$O(m)$|$O(n-m+1)m)$
Finite automaton|$O(m\|\Sigma\|)$|$O(n)$
Knuth-Morris-Pratt|$O(m)$|$O(n)$

在上面的表格中，用m表示匹配串P[0...m-1]（又称为模式串）的长度，n表示被匹配的文本T[0...n-1]的长度

## 暴力匹配

暴力匹配是最直观和简单的字符串匹配算法，非常容易实现。暴力匹配的过程是，在[0,n-m]区间内，找到一个值i，0<=i<=n-m-1，使得P[0...m-1]=T[i...i+m-1]。算法最坏情况下外层循环次数为m-n+1，内层循环为m次，因此时间复杂度为$O((n-m+1)m)$，算法效率低
```java
    int match(String p,String t){
        for(int i=0;i<t.length()-p.length();i++){
            for(int j=0;j<p.length();j++){
                if(p.charAt(j)==t.charAt(i+j)){
                    if(j==p.length()) return i;
                }else break;
            }        
        }
        return -1;
    }
```

## Rabin-Karp算法

Rabin-Karp算法以前几乎没有见过，因为在刷题的时候，看到讨论区中有这个算法，因此顺手搜了这个算法，于是有了这篇总结。Rabin-Karp算法的核心思想首先计算模式串的散列函数，如果找到一个和模式字符串散列值相同的子串，则继续验证两者是否匹配，否则不需要验证。
Rabin-Karp算法把字符串看作是字符集长度进制的数，例如给定字符集$\Sigma={0,1,2,3,4,5,6,7,8,9}$，$\Sigma$的长度d=10，那么任何以$\Sigma$为字符集的串都可以看作d进制数。
记模式串P[0...m-1]对应的十进制数值为P，设$t_s$为T的子串T[s...s+m-1]对应的数值，设P和T都是字符集长度为d的字符串。
则有，$P = P[m-1]+d*(P[m-2]+d*(P[m-3]+...))$

同理，$t_0 = T[m-1]+d*(T[m-2]+d*(P[m-3]+...))$

PK算法的巧妙之处来与通过$t_s$计算$t_{s+1}$。设m=5，d=10，T="314152"，则$t_0=31415$，那么$t_1$的数值可以通过一步运算得到：$t_1 = 10*(t_0 - 10^{5-1}T[0])+T[6] = 10(31415-10^{5-1}*3)+2 = 14152$

由此可以得到通用公式：$t_{s+1} = 10*(t_s - 10^{m-1}*T[s+1])+T[s+m+1],0<=s<=n-m-1$


