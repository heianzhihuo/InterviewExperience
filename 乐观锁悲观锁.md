# 乐观锁与悲观锁

## 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为被人会修改，所以每次拿数据的时候都会上锁，这样其他人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。Java中的synchronized和ReentrantLock等独占锁就是悲观锁。

## 乐观锁

总是假设最好的情况，每次去拿数据的时候都认别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。其中Java中的Atomic类就是乐观锁的一种实现，CAS实现方式。

## 两种锁的使用场景

乐观锁比较适用于写比较少的情况，多读场景，冲突很少发生的情况，省去了锁的开销，加大了系统的整个吞吐量。多写的情况下，用悲观锁比较合适。

# 乐观锁的两种实现方式

## 1.版本号机制

一般是在数据表中加上一个数据版本号的version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version相等时才更新，否则重试更新操作，直到更新成功。

## 2.CAS算法

即compare and swap(比较与交换)，是一种有名的无锁算法。无锁编程，即不用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数
- 需要读写的内存值V
- 进行比较的值A
- 拟写如的值B

当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

# 乐观锁的缺点

## 1 ABA问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍热是A值，那我们就能说明它的值没有被其它线程修改过了吗？很明显不能，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的"ABA"问题

JDK1.5之后的AtomicStampedReference类就提供了这种能力，其中compareAndSet方法就是首先加内存当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等则以原子方式将该引用和该标志设置为给定的更新值。

## 2 循环时间开销大

自旋CAS(也就是不成功一直循环执行直到成功)如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一是可以延迟流水线指令，使CPU不会消耗过多的执行资源，延迟时间取决于具体的实现版本，在一些处理器上延迟时间是0。第二，它可以避免在退出循环的时候因为内存顺序冲突而引起CPU流水线被清空，从而提高CPU执行效率。

## 3 只能保证一个共享变量的原子操作

CAS只对单个共享变量有效，当操作设计跨多个共享变量时CAS无效。但是从JDK1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。所以，我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

# CAS与synchronized的使用情况

1. 对于资源竞争较少，线程冲突较轻的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗CPU资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

2. 对于资源竞争严重，线程冲突严重的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

Java并发编程中，synchronized关键字是很重要的角色，以前一般认为是”重量级锁“。但是，在JDK1.6之后进行了主要包括为了减少获得说和释放锁带来的性能消耗而一如的偏向锁和轻量级锁以及它的各种优化后，变得在某些情况下不那么重了。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争所，稍微牺牲了公平性，提高了吞吐量。


关于Java多线程看了很多，之前一直不太明白，现在逐渐有一些眉目了。这么多和多线程相关的内容，其实最核心的还是线程间的信息传递。而信息传递过程中，最重要的是数据的同步与互斥，因此需要synchronized和volatile这两个关键字，而这两个关键字里的本质还是锁。到了这里逐渐和操作系统接轨了，之前大概对操作系统的锁的掌握也不够深，都是在课程中学到的，当时学到这里的时候是有些困难的。锁在数据库课程中也提到过，但是这些内容都没有串联起来，不同的课程里面从来没有提过。这些东西的核心内容都是相通的，或者说相互关联，有的时候从总体的角度看这些东西，就会明白为什么要这么做。

很多地方都提到synchronized的效率比volatile的效率低，因为synchronized需要用到重量级锁，而重量级锁需要从用户态切换到内核态。但是为什么从重量级锁需要从用户态切换到内核态，重量级锁的到底是什么呢？这是我很疑惑的地方，于是就到了monitor这里，monitor的原理是什么？monitor的本质是基于mutex这种基本原语的，而mutex是由操作系统实现的，系统调用需要进入到内核态。所以本质上，Java的同步机制最终依赖于操作系统实现的锁，mutex和semaphore，而操作系统实现的锁在本质上是通过中断启用和禁止来实现的，为了安全开中断和关中断必需在内核态中进行。除此之外还有一点，重量级锁是需要阻塞进程/线程的，进程管理一般都是由操作系统实现的。