# Java 21 新特性

**分代 ZGC**、**虚拟机线程**、StringTemplate、SequencedCollection、记录模式（Record Patterns）、switch 模式匹配、

## 虚拟线程

虚拟线程是一种由 JVM 管理的轻量级的线程，在很多其他语言中称为协程、纤程、绿色线程、用户态线程等。

操作系统线程需要由操作系统创建并调度资源，线程切换需要耗费大量 CPU 时间，一个系统能同时调度的线程数量是优先的。这种线程是一种重量级的资源。在服务端，对用户请求，通常实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以需要使用线程池来尽量较少线程的频繁创建和销毁，提高资源利用率。对于需要处理大量请求 IO 请求的任务来说，使用线程的效率很低，因为在读写 IO 过程中，线程就必须进入等待状态，直到 IO 数据返回。

而虚拟线程是通过 JVM 管理的，当虚拟线程执行到 IO 操作或其他阻塞操作的时候，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化运行效率。因此虚拟线程可以提高 IO 密集型任务的吞吐量，但对于计算密集型任务，使用虚拟线程无法提高效率，这时只能通过增加 CPU 核心解决，或者使用分布式资源。

# JVM

## JVM 是什么

JVM 是是 Java 虚拟机。编译器把 Java 源码编译成字节码，JVM 负责把机器码转换成机器码，并做一些压缩和优化。使用 JVM，达到跨平台的目的，优化了性能。当前使用最广泛的 Java 虚拟机，是 HotSpot VM。JVM 大致可以分为 3 个部分，分别是类加载器、运行时数据区、执行引擎

## Java 类加载机制

类从被加载到 JVM 开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析这三个阶段被统称为连接。

1. 加载：将字节码转换成二进制字节流加载到内存中，并生成一个代表该类的 java.lang.Class 对象
2. 验证：对二进制字节码进行校验，确保其符合 JVM 字节码规范，保证 JVM 的安全
3. 准备：对类变量（静态变量）分配内存并初始化，分配默认初始值
4. 解析：将常量池中的符号引用转换为直接引用。编译后的字节码中，不知道引用类的实际地址，只能用符号引用替代，而类加载后，类的实际地址已经确定，符号引用需要转换成直接引用（即转成其内存地址）
5. 初始化：类变量赋值为代码期望的值

类加载器：启动类加载器、扩展类加载器、系统类加载器、用户自定义类加载器

双亲委派模型是 Java 类加载器使用的一种机制，用于确保 Java 程序的稳定性和安全性。类加载器在尝试加载一个类时，首先会委派其父加载器去尝试加载这个类，只有在父加载器无法加载该类时，子加载器才会尝试自己去加载。

## JVM 运行时区域

JVM 的运行时数据区通常包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器五个部分。但是随着 JDK 的发展，内存的划分也会有所不同，在 JDK8 后，方法区被彻底移除，取而代之的是元空间。元空间不是 JVM 内存的一部分，而是通过本地内存实现的。

- 程序计数器：所占内存很小，当前线程所执行的字节码指令的行号指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖计数器完成。程序计数器是每个线程私有的。
- Java 虚拟机栈：JVM 栈中是一个个栈帧，没一个栈帧对应一个被调用的方法，栈帧中保存了方法的局部变量、操作数、方法返回地址、动态链接（指向运行时常量池的引用）。JVM 栈是线程私有的，当栈深度超过 JVM 栈的允许深度时，会抛出 StackOverflowError。
- 本地方法栈：和 Java 虚拟机栈类似，本地方法栈是为虚拟机用到的 native 方法服务的
- 堆：所有线程共享的内存区域，几乎所有的对象都会在堆中分配。但从 JDK7 开始，方法中没有被返回或从未被外面使用，那么对象可以直接在栈上分配内存。JIT 编译器通过逃逸分析来判断对象的作用域和生命周期。
- 元空间和方法区：在 JDK7 的时候，方法区被称为永久代，而 JDK8 的时候，永久代被彻底移除。元空间中主要包含运行时常量池、类信息、方法信息、JIT 代码缓存等。其中字符串常量池在堆中。

## 垃圾回收机制

垃圾判断算法：引用计数法和可达性分析法

- 可达性分析法：以 GC Roots 为起点，递归搜索引用的所有对象。当一个对象到 GC Roots 之间没有引用相连的时，即从 GC Roots 到该对象不可达，则说明该对象是需要垃圾收集的。GC Roots 包含：虚拟机栈、本地方法栈、类静态变量、运行时常量池中的常量

STW：Stop The World 是 Java 垃圾收集中的一个重要概念，在垃圾收集的过程中，JVM 会暂停所有用户线程，这种暂停被称为 STW 事件

垃圾收集算法

- 标记清除算法：标记出内存中垃圾对象，然后清理掉这些垃圾对象。这种方法会导致内存碎片
- 复制算法：将内存分成大小相等的两块，每次只使用其中一块。垃圾收集时，将存活的对象从其中一块复制到另一块上面。缺点：内存使用效率低
- 标记整理算法：标记出内存中的垃圾对象，然后将存活对象移动到内存的一端。缺点：效率低
- 分代收集算法：将内存区域划分成几块，对不同区域使用不同的收集算法。老年代和新生代，老年代用标记整理算法，站较大区域，新生代用复制算法，占较小区域。新生代对象根据存活时长，晋升到老年代。在实际使用中，大部分对象都是朝生夕死，存活时间不长，为了避免新生代对象直接被复制到老年代中，增加一个 Suvivor 区，减少被送到老年代的对象。

## 垃圾收集器

ZGC 是 JDK11 推出的低延迟垃圾收集器，适用于大内存低延迟服务的内存管理。STW 时间不超过 10ms，停顿时间不会随着堆大小或活跃对象的大小而增加，支持超大内存的级别的堆

ZGC 基于 Region 进行堆内存的管理，Region 分类包括：Small Region（小区域），大小为 2MB，用于存放小于 256K 的小对象；Medium Region（中区域），大小为 32M，用于存放大于等于 256K 但小于 4MB 的对象；Large Region（大区域）：大小可变，最小是 4MB，每个大区域只用于存放一个大对象，且不会被重新分配。

**染色指针** 一种将少量额外的垃圾标记信息（颜色信息）存储在指针上的技术。在 64 位操作系统中，一个内存的地址总共 64 位，其中高 18 位暂未使用，仅使用低 46 位，支持 64T 的内存空间，只使用 64 位的客观原因是 linux 系统只支持 46 位的物理地址空间。剩余 46 位中，高 4 位用来保存了 4 个标志位，低 42 位用来保存对象的指针，所以 ZGC 最大可以管理的内存不超过 4TB。其中 4 位分别为 Finalizable 标识、Remapped 标志位、Marked1 标志位、Marked0 标志位。其中 M1、M0 用于标记对象在本轮的垃圾回收过程中存活的对象。

**虚拟内存映射** 在 X86 平台上，CPU 的分页管理机制将内存地址分成虚拟内存地址和物理内存地址，通过建立映射表，实现从虚拟地址到物理地址的转换，保证了程序对虚拟地址的访问可以映射到相同的物理地址上。使用分页管理机制，可以将多个不同的虚拟地址映射到同一个物理内存上。ZGC 采用虚拟内存映射技术，将同一块物理内存，映射为 Marked0、Marked 1 和 Remapped 这三个虚拟内存，在分配对象的时候，ZGC 为该对象在这三个视图空间分别分配虚拟地址，这三个虚拟地址对应同一个物理地址。染色指针中，Marked0、Marked1、Remapped 作为 ZGC 的三个视图空间，在同一个时间点内只有一个是有效的。

**读屏障** JVM 向用户代码中插入一小段代码，当应用线程读取对象引用时，会先执行这段代码，只有从堆内存中读取对象引用时，才会执行这一段代码。读屏障会先判断对象的地址是否等于当前视图地址，如果相等则不做处理。如果不相等，则判断当前是否正在转移，如果正在转移，则进入转移操作。如果不在转移，判断是否为强引用，如果是，则进入标记操作，如果不是则进入重定位操作。

**ZGC 过程**

1. 初始标记：STW-1（0.3ms）。决定本轮 GC 存活对象的颜色（good_mask 值）是 M0 还是 M1，如果是 M0，则把存活对象的 M0 位置为 1，否则把存活对象的 M1 位置为 1。分配新的内存页，，本次 GC 周期只针对 STW-1 之前已分配的页进行 GC，不对 STW-1 开启后创建的对象进行 GC。遍历 GC Roots，将 GC Roots 直接引用的指针保存到遍历栈中。
2. 并发标记/重定向：业务线程和垃圾回收器线程同时进行，标记剩余的对象。GC 标记线程访问对象时，如果对象是 Remapped 的，则切换到 Marked0，如果已经是 Marked0 的，不处理；用户线程创建的对象，直接进入 Marked0，用户线程访问的对象，也标记为 Marked0。标记结束后，如果对象地址是 Marked0 的，则是活跃的，否则是不活跃的。同时，修复上一次 GC 时被标记的指针
3. 再标记：STW-2（1ms），修正并发标记阶段由于并发引起的错标和漏标等问题。
4. 并发转移准备：为之后的对象迁移做准备，重置转发表（Forwarding table），转发表的作用是记录需要转移的对象，以及转移对象新旧地址的映射关系。这个过程需要扫描整个堆空间的所有 Page，将需要迁移的 Page 添加到重分配集合。这一步非常耗时，需要全量扫面所有 Page，但是这个过程和用户线程并发运行，不会 STW。
5. 初始转移：STW-3，转移 GC Roots 直接引用的存活对象，存活的对象会被标记为 Remapped，且 good_mask 切换为 Remapped。迁移对象时，可能需要将这些对象复制到新的 Page 中，对象转移后，会修正 GC Roots 指向这些对象的指针，这个过程就是指针自愈。
6. 并发转移：这个阶段需要遍历所有的页，并根据之前的转发表，将存活的对象复制到新 Page 中，然后在转发表里记录对象新旧地址的对应关系。当一个 Page 中的对象都被迁移完毕后，这个 Page 就会被回收掉。如果这个阶段有用户线程访问了被迁移后的对象，那么会根据转发表修正指向这个对象的地址。
7. 并发重定位：修正所有被迁移后的对象的引用，这个阶段会放在下一轮 GC 的并发标记阶段完成。因为这个过程需要遍历所有的对象，而在下一轮 GC 的并发标记阶段同样需要遍历所有的对象，因此可以减少一次遍历所有对象的操作。

**三色标记法**

- 白色：这个对象还没有被访问过，初始阶段所有对象都是白色的，如果枚举完后，所有对象仍是白色的，则这些对象会被当做垃圾对象清理掉
- 灰色：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有一个没有被访问到
- 黑色：对象和它所有直接引用的对象都被访问过

# Java 并发编程

## 1. synchronized 详解

### 1.1. synchronized 基本用法

用于修饰方法或代码块

- 同步方法：对象锁
- 同步代码块：对象锁，需要指定锁对象
- 同步静态方法：修饰静态方法，或执行对象为 Class 对象

### 1.2. synchronized 原理和锁升级机制

JDK1.6 以前，synchronized 是通过重量级锁实现的。JDK1.5 及其以后，引入了偏向所和轻量级锁，一个对象有 4 种状态：

- 无锁：没有对资源进行锁定，任何线程可以尝试修改和访问
- 偏向锁：只有一个线程访问同步块，加解锁几乎不需要额外的消耗
- 轻量级锁：通过自旋获取锁，占用 CPU，但响应快
- 重量级锁：阻塞线程，不消耗 CPU，但响应缓慢

每个 Java 对象都有一个对象头。非数组类型，则用 2 个位宽来存储对象头，如果是数组，则用 3 个字宽来存储对象头。32 位的 CPU，一个字宽是 32 位；64 位 CPU，一个字宽是 64 位。一个位宽用于存储对象的 hashCode 或锁信息，叫做 Mark Word；一个用于存储对象类型数据的指针；如果是数组，第三个字宽用于存储数组长度。

在 Mark Word 中，用 1bit 来存储偏向锁标志，2bit 来存储锁标志；剩余的 bit 根据锁的状态不同，可用于存储：对象 hashCode、线程 ID、指向栈中锁记录的指针、指向互斥量（重量级锁）的指针。

对象的初始状态为无锁状态，Mark Word 中存储了对象的 hashCode，偏向锁标志为 0，锁标志为 01。当一个线程第一次进入同步块时，会在对象头中记录线程 ID，并将偏向锁标志修改为 1，此时为偏向锁状态。当下次某个线程再次进入这个同步块时，会去检查 Mark Word 中的线程 ID 是不是自己的线程 ID。如果是，表明该线程已经获取了锁，该线程在进入和退出同步块时，不需要重新加锁和解锁；如果不是，则代表有另一个线程竞争这个偏向锁。这个时候，会尝试使用 CAS 操作来替换 Mark Word 里的线程 ID，这个时候分成两种情况：

- 成功：匿名偏向锁状态，之前的线程不存在了，对象头的线程 ID 替换成新的线程 ID，锁不升级
- 失败：开始进行偏向锁撤销。偏向锁撤销需要等待安全局点，即在某个时间点上没有字节码正在执行检查拥有偏向锁的线程是否存活并正在执行同步块中的代码。如果线程存在且正在执行同步块代码，则升级轻量级锁；否则，设置为匿名偏向锁状态。

JVM 会在每个线程的栈帧中创建用于记录存储锁记录的空间，称为 Displaced Mark Word。如果一个线程获得锁时，发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 中。线程会尝试使用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，则获得锁；如果失败，则当前线程会尝试自旋的方式获取锁。自旋通过循环的方式实现，需要消耗 CPU，如果线程一直获取不到锁，线程会一直处于自旋状态。自旋的次数是有上限的，JDK 采用自适应自旋的方式动态调整自旋的次数。如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，这个线程会进入阻塞状态。同时锁也会升级成重量级锁

重量级锁依赖于操作系统的互斥锁（mutex）实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但是被阻塞的线程不会消耗 CPU。当一个线程尝试获得锁时，如果锁已被占用，则该线程会被插入到阻塞队列中，线程被挂起。当有一个线程释放锁时，会从阻塞队列中挑选一个线程唤醒。synchronized 的重量级锁是非公平的。

### 1.3. synchronized 不足

- 如果临界区是只读操作，可以多个线程一起执行，但使用 synchronized，同一时间只能有一个线程执行
- synchronized 无法知道线程有没有成功获取到锁
- 使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待

## 2. 乐观锁 CAS 原理

CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为比较并交换，是一种无锁的原子操作，基于 CPU 提供的原子指令集。比较要更新的变量是否等于目标值，如果是，则将变量值设置为新值；如果不相等，则什么都不做，如果不相等，则会循环执行 CAS 操作，即自旋。

## 3. Java 线程的 6 种状态

- new：创建，但未启动，即没有调用 start 方法
- runnable：运行中，或者在等待 CPU 分配资源。（包含就绪和运行中）
- blocked：阻塞状态，处于阻塞态的线程正在等待锁
- waiting：等待状态，处于等待状态的线程需要被其他线程唤醒（notify、notifyAll）才能进入 runnable
- timed_waiting：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。Thread.sleep(xxx)， Object.wait(xxx)
- terminated：终止状态，线程已执行完毕

## 4. Java 内存模型（JMM）

Java 使用共享内存并发模型。所有线程的共享变量存在主存（堆）中，每个线程都保存了一份该线程使用到的共享变量的副本，保存在线程的本地内存中。本地内存是 Java 内存模型的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器等。两个线程需要通信时，线程 A 将本地内存中的共享变量刷新到主存中取，线程 B 从主存中读取线程 A 更新后的共享变量。

## 5. volatile 关键字

volatile 关键字可以保证可见性，但不保证原子性；可以禁止指令重排序。当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新的主存中去；同时，这个写操作会导致其他线程中的 volatile 变量缓存失效。

## 6. 锁分类和 JUC

- 乐观锁和悲观锁：是否需要锁住同步的资源。乐观锁认为自己试用数据的时候，不会有别的线程修改数据，所以不会加锁；悲观锁认为自己使用数据的时候，一定会有别的线程来修改数据，所以在获取数据的时候，会先加锁。Java 中的乐观锁是采用 CAS 算法，Java 原子类的操作就是通过 CAS 实现的。互斥量就是典型的悲观锁。
- 自旋锁和适应性自旋锁：阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态完成，这种状态转换耗费 CPU 时间较长。有很多场景中，同步资源的锁定时间很短，线程的挂起和恢复花费的时间会导致效率低下。为了让线程等待一下，可以让线程进行自旋，即循环获取直到获取成功，这样可以避免线程切换开销。当然，自旋需要占用 CPU 时间，如果自旋次数太多，也会导致 CPU 浪费。因此，自旋超过限定次数没有获得锁，就应当挂起线程。JDK 会动态调整自旋的次数，如果在同一个锁对象上，自旋刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而它将允许自旋等待更长的时间。
- 可重入锁和非可重入锁：可重入锁右称为递归锁，指一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。Java 中的 ReentrantLock 和 synchronized 都是可重入锁。非可重入锁，同一个线程在获取一个锁时，必需要释放这个锁后，才能再次获取这个锁，否则将阻塞。Java 中的 NonReentrantLock 是非可重入锁。
- 公平锁和非公平锁：先请求锁的线程会先获得锁，遵守先来后到的规则，FIFO。反之，则是非公平锁。一般情况下，非公平锁能提升一定的效率。ReentrantLock 支持非公平和公平两种
- 读写锁和排他锁：读写锁可以在同一个时刻允许多个线程访问，读锁允许多个线程访问，写锁只允许一个线程访问，ReentrantReadWriteLock 是 Java 的读写锁。排他锁也叫独享锁，同一时刻只允许一个线程访问。

## 7. HashMap、HashTable、ConcurrentHashMap

HashMap、HashTable、ConcurrentHashMap 是一种 kev-value 形式的数据结构，底层都是通过数组+链表的形式实现的

- HashMap: key 和 value 都可以为 null，**线程不安全**。当链表长度超过阈值 8 时，会把链表转换为红黑树；同样，如果后续删除或调整大小后，节点数小于等于 6 时，会转换成链表形态。
- HashTable：key 和 value 都不能为 null，线程安全，通过 synchronized 关键字锁住整个表，效率低。
- ConcurrentHashMap：在 JDK7 中，通过分段锁的形式实现。在 JDK8 后，使用 CAS+synchronized 来保证并发安全性

## 8. 线程池

线程池是一种池化的技术实现，核心思想是实现资源的复用，避免线程重复创建和销毁带来的性能开销。降低资源消耗、提高响应速度、提高线程可管理性。其核心参数：

- 核心线程数：线程池创建时初始化的线程数。当线程池中可用的线程数量小于核心线程数时，会通过创建新的线程来运行任务
- 最大线程数：线程池允许创建的最大线程数
- 任务队列：线程达到核心线程数后，会将任务存储在阻塞队列中
- 线程最大存活时间：超出核心线程数创建的线程存活的时间
- 拒绝策略：当队列已满，且线程数达到最大线程数量时，后续任务的处理策略

# Java 基础知识点

## JVM vs JDK vs JRE

- JVM：Java 虚拟机（Java Virtual Machine）是运行 Java 字节码的虚拟机。使用最广泛的 JVM 是 HotSpot VM
- JDK：Java 开发工具包（Java Development Kit），包含 JRE 和用于开发调试 Java 程序的工具
- JRE：Java 运行环境（Java Runtime Environment），只包含运行 Java 程序所需的环境，包括 JVM 和 Java 基础类库

## 包装类和基本类型

- 8 种基本类型：byte、short、int、long、char、float、double、boolean
- 包装类型：包装类型占用空间相对较大，默认值为 null。其中 Byte、Short、Integer、Long 这 4 种类型，默认创建了\[-128,127]的响应类型的缓存数据。自动拆箱、装箱，分别调用了 xxxValue()和 valueOf()方法

## Object 常见方法

getClass、hashCode、equals、clone、toString、notify、notifyAll、wait、finalize

### equals 和 hashCode

- ==用于判断两个值是否相等，对于基本类型则直接比较值，对象则判断地址是否相同
- equals 的作用是判断两个对象是否相等。如果一个类没有重写 equals 方法，此时等价于==；如果重写了 equals 方法， 则通常比较两个对象的内容是否相等
- hashCode 的作用是用于计算一个对象的哈希值，也称为散列码，返回值为 int 类型。Java 中的任何类都包含 hashCode 函数。hashCode 通常在 HashSet 和 HashMap 中用到。

HashSet 和 HashMap 比较对象是否相等时，会先比较两个对象的 hashCode 值。如果 hashCode 不相等，那么这两个对象不相等；如果 hashCode 相等，则再调用 equals 方法判断两个对象相等。因此在重写 equals 方法的时候，必须重写 hashCode 方法，否则，可能会导致两个相等的对象，hashCode 却不相等，在将两个相等的对象添加到 HashSet 中时，由于它们的 hashCode 值不相等，它们会被当成两个不同对象添加到集合中。

## String、StringBuilder、StringBuffer

- String：final，不可变，线程安全，部分字符串在字符串常量池中
- StringBuilder：可变，线程不安全，提供了很多修改字符串的方法，比如添加、替换、删除等，适用于单线程环境下操作大量字符，在循环中拼接字符串时建议使用StringBuilder效率会更高
- StringBuffer：和 StringBuilder 一样，是可以变的，继承自 AbstractStringBuilder 类，线程安全，适用于多线程环境下字符串操作

### 字符串常量

编译器可以确定的字符串，也就是常量字符串，jvm会将其存入字符串常量池。String#intern方法是一个本地方法，用来处字符串常量池中字符串对象的引用，如果字符串常量池中有相同内容的字符串，则intern方法会返回常量池中该对象的引用；如果常量池中没有相同内容的字符串对象，intern方法会将当前字符串对象的引用添加到常量池中，并返回该引用

## 异常

### Java异常类Exception和Error的区别

Java中，所有的异常类都有一个共同的祖先java.lang.Throwable类

- Exception：程序本身可以处理的异常，可以通过catch捕获，又可以分为Checked异常、Unchecked异常
- Error：属于程序无法处理的错误，不建议使用catch捕获，例如OutOfMemoryError、NoClassDefFoundError等

### 如何使用try-with-resources代替try-catch-finally

适用于实现了java.lang.AutoCloseable或者java.io.Closeable的对象。通过使用分号分隔，可以在try-with-resources中声明多个资源

## Java值传递

Java中只有值传递，通过swap方法，无法完成两个int类型数值的交换。如果方法参数是对象，此时传递的参数是对象地址的值，如果是数组对象，传递的是数组对象的地址。

## Java集合
Java集合，也叫做容器，主要由两大接口派生：一个是Collection接口，主要用于存放单一元素；另一个是Map接口，主要用于存放key-value的键值对。Collection接口，下面有三个主要子接口：List、Set、Queue。Map接口，下面主要有两个子接口：HashMap、SortedMap。

- List：有序的元素，可重复
- Set：不可重复
- Queue：按照特定排序规则确定先后顺序，有序、可重复
- Map：key是不可重复的，value可重复

### 集合底层数据结构和特性总结

#### List
- ArrayList：Object[]数组，使用连续的内存空间存储，支持下标访问，在插入元素时，需要移动容器中的元素，所以对于数据的插入操作执行较慢。线程不安全
- Vector：Object[]数组，和ArrayList功能类似，不同点在于，Vector线程安全
- LinkedList：双向链表实现的，对数据的索引需要从列表头开始遍历，但是在尾部或头部插入元素时，不需要对数据进行移动，插入效率比较高，线程不安全

#### Set
- HashSet：无序，不可重复，基于HashMap实现的，底层采用HashMap来保存元素
- LinkedHashSet：HashSet的子类，保持了插入顺序，内部通过LinkedHashMap实现
- TreeSet：有序，不重复，红黑树

#### Map

- HashMap：数组+链表实现，当链表长度大于阈值时，会转换成红黑树
- LinkedHashMap：继承自HashMap，基于HashMap的结构，增加了一条双向链表，保证键值对的插入顺序
- TreeMap：红黑树
