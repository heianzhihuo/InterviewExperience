# Java 21新特性
**分代ZGC**、**虚拟机线程**、StringTemplate、SequencedCollection、记录模式（Record Patterns）、switch模式匹配、

## 虚拟线程
用户模式线程或纤程。虚拟线程是由JVM管理的轻量级线程，不需要任何显示分配或调度，适合I/O密集型任务，并发编程简单

# JVM

## JVM是什么
JVM是是Java虚拟机。编译器把Java源码编译成字节码，JVM负责把机器码转换成机器码，并做一些压缩和优化。使用JVM，达到跨平台的目的，优化了性能。当前使用最广泛的Java虚拟机，是HotSpot VM。JVM大致可以分为3个部分，分别是类加载器、运行时数据区、执行引擎

## Java类加载机制

类从被加载到JVM开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析这三个阶段被统称为连接。
1. 加载：将字节码转换成二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象
2. 验证：对二进制字节码进行校验，确保其符合JVM字节码规范，保证JVM的安全
3. 准备：对类变量（静态变量）分配内存并初始化，分配默认初始值
4. 解析：将常量池中的符号引用转换为直接引用。编译后的字节码中，不知道引用类的实际地址，只能用符号引用替代，而类加载后，类的实际地址已经确定，符号引用需要转换成直接引用（即转成其内存地址）
5. 初始化：类变量赋值为代码期望的值

类加载器：启动类加载器、扩展类加载器、系统类加载器、用户自定义类加载器

双亲委派模型是Java类加载器使用的一种机制，用于确保Java程序的稳定性和安全性。类加载器在尝试加载一个类时，首先会委派其父加载器去尝试加载这个类，只有在父加载器无法加载该类时，子加载器才会尝试自己去加载。


## JVM运行时区域
JVM的运行时数据区通常包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器五个部分。但是随着JDK的发展，内存的划分也会有所不同，在JDK8后，方法区被彻底移除，取而代之的是元空间。元空间不是JVM内存的一部分，而是通过本地内存实现的。
- 程序计数器：所占内存很小，当前线程所执行的字节码指令的行号指示器，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖计数器完成。程序计数器是每个线程私有的。
- Java虚拟机栈：JVM栈中是一个个栈帧，没一个栈帧对应一个被调用的方法，栈帧中保存了方法的局部变量、操作数、方法返回地址、动态链接（指向运行时常量池的引用）。JVM栈是线程私有的，当栈深度超过JVM栈的允许深度时，会抛出StackOverflowError。
- 本地方法栈：和Java虚拟机栈类似，本地方法栈是为虚拟机用到的native方法服务的
- 堆：所有线程共享的内存区域，几乎所有的对象都会在堆中分配。但从JDK7开始，方法中没有被返回或从未被外面使用，那么对象可以直接在栈上分配内存。JIT编译器通过逃逸分析来判断对象的作用域和生命周期。
- 元空间和方法区：在JDK7的时候，方法区被称为永久代，而JDK8的时候，永久代被彻底移除。元空间中主要包含运行时常量池、类信息、方法信息、JIT代码缓存等。其中字符串常量池在堆中。

## 垃圾回收机制

垃圾判断算法：引用计数法和可达性分析法
- 可达性分析法：以GC Roots为起点，递归搜索引用的所有对象。当一个对象到GC Roots之间没有引用相连的时，即从GC Roots到该对象不可达，则说明该对象是需要垃圾收集的。GC Roots包含：虚拟机栈、本地方法栈、类静态变量、运行时常量池中的常量

STW：Stop The World是Java垃圾收集中的一个重要概念，在垃圾收集的过程中，JVM会暂停所有用户线程，这种暂停被称为STW事件

垃圾收集算法
- 标记清除算法：标记出内存中垃圾对象，然后清理掉这些垃圾对象。这种方法会导致内存碎片
- 复制算法：将内存分成大小相等的两块，每次只使用其中一块。垃圾收集时，将存活的对象从其中一块复制到另一块上面。缺点：内存使用效率低
- 标记整理算法：标记出内存中的垃圾对象，然后将存活对象移动到内存的一端。缺点：效率低
- 分代收集算法：将内存区域划分成几块，对不同区域使用不同的收集算法。老年代和新生代，老年代用标记整理算法，站较大区域，新生代用复制算法，占较小区域。新生代对象根据存活时长，晋升到老年代。在实际使用中，大部分对象都是朝生夕死，存活时间不长，为了避免新生代对象直接被复制到老年代中，增加一个Suvivor区，减少被送到老年代的对象。

## 垃圾收集器

ZGC是JDK11推出的低延迟垃圾收集器，适用于大内存低延迟服务的内存管理。STW时间不超过10ms，停顿时间不会随着堆大小或活跃对象的大小而增加，支持超大内存的级别的堆

ZGC基于Region进行堆内存的管理，Region分类包括：Small Region（小区域），大小为2MB，用于存放小于256K的小对象；Medium Region（中区域），大小为32M，用于存放大于等于256K但小于4MB的对象；Large Region（大区域）：大小可变，最小是4MB，每个大区域只用于存放一个大对象，且不会被重新分配。

**染色指针** 一种将少量额外的垃圾标记信息（颜色信息）存储在指针上的技术。在64位操作系统中，一个内存的地址总共64位，其中高18位暂未使用，仅使用低46位，支持64T的内存空间，只使用64位的客观原因是linux系统只支持46位的物理地址空间。剩余46位中，高4位用来保存了4个标志位，低42位用来保存对象的指针，所以ZGC最大可以管理的内存不超过4TB。其中4位分别为Finalizable标识、Remapped标志位、Marked1标志位、Marked0标志位。其中M1、M0用于标记对象在本轮的垃圾回收过程中存活的对象。

**虚拟内存映射** 在X86平台上，CPU的分页管理机制将内存地址分成虚拟内存地址和物理内存地址，通过建立映射表，实现从虚拟地址到物理地址的转换，保证了程序对虚拟地址的访问可以映射到相同的物理地址上。使用分页管理机制，可以将多个不同的虚拟地址映射到同一个物理内存上。ZGC采用虚拟内存映射技术，将同一块物理内存，映射为Marked0、Marked 1和Remapped这三个虚拟内存，在分配对象的时候，ZGC为该对象在这三个视图空间分别分配虚拟地址，这三个虚拟地址对应同一个物理地址。染色指针中，Marked0、Marked1、Remapped作为ZGC的三个视图空间，在同一个时间点内只有一个是有效的。

**读屏障** JVM向用户代码中插入一小段代码，当应用线程读取对象引用时，会先执行这段代码，只有从堆内存中读取对象引用时，才会执行这一段代码。读屏障会先判断对象的地址是否等于当前视图地址，如果相等则不做处理。如果不相等，则判断当前是否正在转移，如果正在转移，则进入转移操作。如果不在转移，判断是否为强引用，如果是，则进入标记操作，如果不是则进入重定位操作。

**ZGC过程**
1. 初始标记：STW-1（0.3ms）。决定本轮GC存活对象的颜色（good_mask值）是M0还是M1，如果是M0，则把存活对象的M0位置为1，否则把存活对象的M1位置为1。分配新的内存页，，本次GC周期只针对STW-1之前已分配的页进行GC，不对STW-1开启后创建的对象进行GC。遍历GC Roots，将GC Roots直接引用的指针保存到遍历栈中。
2. 并发标记/重定向：业务线程和垃圾回收器线程同时进行，标记剩余的对象。GC标记线程访问对象时，如果对象是Remapped的，则切换到Marked0，如果已经是Marked0的，不处理；用户线程创建的对象，直接进入Marked0，用户线程访问的对象，也标记为Marked0。标记结束后，如果对象地址是Marked0的，则是活跃的，否则是不活跃的。同时，修复上一次GC时被标记的指针
3. 再标记：STW-2（1ms），修正并发标记阶段由于并发引起的错标和漏标等问题。
4. 并发转移准备：为之后的对象迁移做准备，重置转发表（Forwarding table），转发表的作用是记录需要转移的对象，以及转移对象新旧地址的映射关系。这个过程需要扫描整个堆空间的所有Page，将需要迁移的Page添加到重分配集合。这一步非常耗时，需要全量扫面所有Page，但是这个过程和用户线程并发运行，不会STW。
5. 初始转移：STW-3，转移GC Roots直接引用的存活对象，存活的对象会被标记为Remapped，且good_mask切换为Remapped。迁移对象时，可能需要将这些对象复制到新的Page中，对象转移后，会修正GC Roots指向这些对象的指针，这个过程就是指针自愈。
6. 并发转移：这个阶段需要遍历所有的页，并根据之前的转发表，将存活的对象复制到新Page中，然后在转发表里记录对象新旧地址的对应关系。当一个Page中的对象都被迁移完毕后，这个Page就会被回收掉。如果这个阶段有用户线程访问了被迁移后的对象，那么会根据转发表修正指向这个对象的地址。
7. 并发重定位：修正所有被迁移后的对象的引用，这个阶段会放在下一轮GC的并发标记阶段完成。因为这个过程需要遍历所有的对象，而在下一轮GC的并发标记阶段同样需要遍历所有的对象，因此可以减少一次遍历所有对象的操作。

**三色标记法** 
- 白色：这个对象还没有被访问过，初始阶段所有对象都是白色的，如果枚举完后，所有对象仍是白色的，则这些对象会被当做垃圾对象清理掉
- 灰色：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有一个没有被访问到
- 黑色：对象和它所有直接引用的对象都被访问过


# Java并发编程

## 1. synchronized 详解

### 1.1. synchronized 基本用法

用于修饰方法或代码块

- 同步方法：对象锁
- 同步代码块：对象锁，需要指定锁对象
- 同步静态方法：修饰静态方法，或执行对象为 Class 对象

### 1.2. synchronized 原理和锁升级机制

JDK1.6 以前，synchronized 是通过重量级锁实现的。JDK1.5 及其以后，引入了偏向所和轻量级锁，一个对象有 4 种状态：

- 无锁：没有对资源进行锁定，任何线程可以尝试修改和访问
- 偏向锁：只有一个线程访问同步块，加解锁几乎不需要额外的消耗
- 轻量级锁：通过自旋获取锁，占用 CPU，但响应快
- 重量级锁：阻塞线程，不消耗 CPU，但响应缓慢

每个 Java 对象都有一个对象头。非数组类型，则用 2 个位宽来存储对象头，如果是数组，则用 3 个字宽来存储对象头。32 位的 CPU，一个字宽是 32 位；64 位 CPU，一个字宽是 64 位。一个位宽用于存储对象的 hashCode 或锁信息，叫做 Mark Word；一个用于存储对象类型数据的指针；如果是数组，第三个字宽用于存储数组长度。

在 Mark Word 中，用 1bit 来存储偏向锁标志，2bit 来存储锁标志；剩余的 bit 根据锁的状态不同，可用于存储：对象 hashCode、线程 ID、指向栈中锁记录的指针、指向互斥量（重量级锁）的指针。

对象的初始状态为无锁状态，Mark Word 中存储了对象的 hashCode，偏向锁标志为 0，锁标志为 01。当一个线程第一次进入同步块时，会在对象头中记录线程 ID，并将偏向锁标志修改为 1，此时为偏向锁状态。当下次某个线程再次进入这个同步块时，会去检查 Mark Word 中的线程 ID 是不是自己的线程 ID。如果是，表明该线程已经获取了锁，该线程在进入和退出同步块时，不需要重新加锁和解锁；如果不是，则代表有另一个线程竞争这个偏向锁。这个时候，会尝试使用 CAS 操作来替换 Mark Word 里的线程 ID，这个时候分成两种情况：

- 成功：匿名偏向锁状态，之前的线程不存在了，对象头的线程 ID 替换成新的线程 ID，锁不升级
- 失败：开始进行偏向锁撤销。偏向锁撤销需要等待安全局点，即在某个时间点上没有字节码正在执行检查拥有偏向锁的线程是否存活并正在执行同步块中的代码。如果线程存在且正在执行同步块代码，则升级轻量级锁；否则，设置为匿名偏向锁状态。

JVM 会在每个线程的栈帧中创建用于记录存储锁记录的空间，称为 Displaced Mark Word。如果一个线程获得锁时，发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 中。线程会尝试使用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，则获得锁；如果失败，则当前线程会尝试自旋的方式获取锁。自旋通过循环的方式实现，需要消耗 CPU，如果线程一直获取不到锁，线程会一直处于自旋状态。自旋的次数是有上限的，JDK 采用自适应自旋的方式动态调整自旋的次数。如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，这个线程会进入阻塞状态。同时锁也会升级成重量级锁

重量级锁依赖于操作系统的互斥锁（mutex）实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但是被阻塞的线程不会消耗 CPU。当一个线程尝试获得锁时，如果锁已被占用，则该线程会被插入到阻塞队列中，线程被挂起。当有一个线程释放锁时，会从阻塞队列中挑选一个线程唤醒。synchronized 的重量级锁是非公平的。

### 1.3. synchronized 不足

- 如果临界区是只读操作，可以多个线程一起执行，但使用 synchronized，同一时间只能有一个线程执行
- synchronized 无法知道线程有没有成功获取到锁
- 使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待

## 2. 乐观锁 CAS 原理

CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为比较并交换，是一种无锁的原子操作，基于 CPU 提供的原子指令集。比较要更新的变量是否等于目标值，如果是，则将变量值设置为新值；如果不相等，则什么都不做，如果不相等，则会循环执行 CAS 操作，即自旋。

## 3. Java 线程的 6 种状态

- new：创建，但未启动，即没有调用 start 方法
- runnable：运行中，或者在等待 CPU 分配资源。（包含就绪和运行中）
- blocked：阻塞状态，处于阻塞态的线程正在等待锁
- waiting：等待状态，处于等待状态的线程需要被其他线程唤醒（notify、notifyAll）才能进入 runnable
- timed_waiting：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。Thread.sleep(xxx)， Object.wait(xxx)
- terminated：终止状态，线程已执行完毕

## 4. Java 内存模型（JMM）

Java 使用共享内存并发模型。所有线程的共享变量存在主存（堆）中，每个线程都保存了一份该线程使用到的共享变量的副本，保存在线程的本地内存中。本地内存是 Java 内存模型的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器等。两个线程需要通信时，线程 A 将本地内存中的共享变量刷新到主存中取，线程 B 从主存中读取线程 A 更新后的共享变量。

## 5. volatile 关键字

volatile 关键字可以保证可见性，但不保证原子性；可以禁止指令重排序。当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新的主存中去；同时，这个写操作会导致其他线程中的 volatile 变量缓存失效。

## 6. 锁分类和JUC
- 乐观锁和悲观锁：是否需要锁住同步的资源。乐观锁认为自己试用数据的时候，不会有别的线程修改数据，所以不会加锁；悲观锁认为自己使用数据的时候，一定会有别的线程来修改数据，所以在获取数据的时候，会先加锁。Java中的乐观锁是采用CAS算法，Java原子类的操作就是通过CAS实现的。互斥量就是典型的悲观锁。
- 自旋锁和适应性自旋锁：阻塞或唤醒一个Java线程需要操作系统切换CPU状态完成，这种状态转换耗费CPU时间较长。有很多场景中，同步资源的锁定时间很短，线程的挂起和恢复花费的时间会导致效率低下。为了让线程等待一下，可以让线程进行自旋，即循环获取直到获取成功，这样可以避免线程切换开销。当然，自旋需要占用CPU时间，如果自旋次数太多，也会导致CPU浪费。因此，自旋超过限定次数没有获得锁，就应当挂起线程。JDK会动态调整自旋的次数，如果在同一个锁对象上，自旋刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而它将允许自旋等待更长的时间。
- 可重入锁和非可重入锁：可重入锁右称为递归锁，指一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。Java中的ReentrantLock和synchronized都是可重入锁。非可重入锁，同一个线程在获取一个锁时，必需要释放这个锁后，才能再次获取这个锁，否则将阻塞。Java中的NonReentrantLock是非可重入锁。
- 公平锁和非公平锁：先请求锁的线程会先获得锁，遵守先来后到的规则，FIFO。反之，则是非公平锁。一般情况下，非公平锁能提升一定的效率。ReentrantLock支持非公平和公平两种
- 读写锁和排他锁：读写锁可以在同一个时刻允许多个线程访问，读锁允许多个线程访问，写锁只允许一个线程访问，ReentrantReadWriteLock是Java的读写锁。排他锁也叫独享锁，同一时刻只允许一个线程访问。

## 7. HashMap、HashTable、ConcurrentHashMap
HashMap、HashTable、ConcurrentHashMap是一种kev-value形式的数据结构，底层都是通过数组+链表的形式实现的
- HashMap: key和value都可以为null，**线程不安全**。当链表长度超过阈值8时，会把链表转换为红黑树；同样，如果后续删除或调整大小后，节点数小于等于6时，会转换成链表形态。
- HashTable：key和value都不能为null，线程安全，通过synchronized关键字锁住整个表，效率低。
- ConcurrentHashMap：在JDK7中，通过分段锁的形式实现。在JDK8后，使用CAS+synchronized来保证并发安全性

## 8. 线程池
线程池是一种池化的技术实现，核心思想是实现资源的复用，避免线程重复创建和销毁带来的性能开销。降低资源消耗、提高响应速度、提高线程可管理性。其核心参数：
- 核心线程数：线程池创建时初始化的线程数。当线程池中可用的线程数量小于核心线程数时，会通过创建新的线程来运行任务
- 最大线程数：线程池允许创建的最大线程数
- 任务队列：线程达到核心线程数后，会将任务存储在阻塞队列中
- 线程最大存活时间：超出核心线程数创建的线程存活的时间
- 拒绝策略：当队列已满，且线程数达到最大线程数量时，后续任务的处理策略

##

1. HashTable,HashMap,ConcurrentHashMap

- HashTable - 数组+链表实现，key 和 value 都**不能为 null**，线程安全，实现线程安全的方式是锁住整个 HashTable，效率低，ConcurrentHashMap 做了相关优化 - 初始化 size 为 11，扩容：newsize = oldsize\*2+1，size 始终为奇数，所以简单取模哈希的结果更加均匀 - 计算 index 的方法：index = (hash & 0x7FFFFFFF) % tab.length，位运算的目的是得到一个正数
- HashMap - 数组+链表实现，key 和 value 都**可以为 null**，**线程不安全** - size 初始化为 16，扩容 newsize = oldsize\*2，size 为 2 的 n 次幂 - 扩容针对整个 Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 - 插入元素后才判断该不该扩容，有可能有无效扩容（插入后，如果扩容，但没有再次插入，可能产生无效扩容） - 当 Map 中元素总数超过 Entry 数组的 75%，触发扩容操作，为了减小链表长度，元素分配更均匀 - 计算 index 的方法：index = hash & (tab.length-1) - 为 null 的键只能有一个，可以有一个或多个键对应的值为 null - 当链表大小超过阈值 8 时，链表就会被改造为树形结构（红黑树，在 Java1.8 中引入）
- HashMap 的初始值还要考虑加载因子 - 哈希冲突：若干 key 的哈希值按数组大小取模后，如果落在同一个数组下表下，将组成一条 Entry 链，对 key 的查找需要遍历真个链表的元素执行 equals（）比较 - 加载因子：为了降低哈希冲突概率，默认当 HashMap 中的键值对数达到数组大小的 75%时，会触发扩容。即当预估容量是 100 时，需要设定 100/0.75=134 的数组大小 - 空间换时间：如果希望加快 Key 查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突概率
- HashMap 和 HashTable 包含如下属性 - 容量(capacity) - 初始化容量(initial capacity) - 尺寸(size)：当前在 hash 表中记录的数量 - 负载因子(load factor)
- ConcurrentHashMap - 底层采用分段数组+链表实现，线程安全 - 通过把 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升了 N 倍，默认提升 16 倍 - ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术 - 有些方法需要跨段，比如 size()和 containsValue() - 扩容：段内扩容（段内元素超过该段对应 Entry 数组长度的 75%触发扩容，不会对整个 Map 进行扩容），插入前检测需不需扩容，避免无效扩容
- **锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据一把锁

