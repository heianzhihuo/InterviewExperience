# Java 常见面试题总结

## 1. synchronized 详解

### 1.1. synchronized 基本用法

用于修饰方法或代码块

- 同步方法：对象锁
- 同步代码块：对象锁，需要指定锁对象
- 同步静态方法：修饰静态方法，或执行对象为 Class 对象

### 1.2. synchronized 原理和锁升级机制

JDK1.6 以前，synchronized 是通过重量级锁实现的。JDK1.5 及其以后，引入了偏向所和轻量级锁，一个对象有 4 种状态：

- 无锁：没有对资源进行锁定，任何线程可以尝试修改和访问
- 偏向锁：只有一个线程访问同步块，加解锁几乎不需要额外的消耗
- 轻量级锁：通过自旋获取锁，占用 CPU，但响应快
- 重量级锁：阻塞线程，不消耗 CPU，但响应缓慢

每个 Java 对象都有一个对象头。非数组类型，则用 2 个位宽来存储对象头，如果是数组，则用 3 个字宽来存储对象头。32 位的 CPU，一个字宽是 32 位；64 位 CPU，一个字宽是 64 位。一个位宽用于存储对象的 hashCode 或锁信息，叫做 Mark Word；一个用于存储对象类型数据的指针；如果是数组，第三个字宽用于存储数组长度。

在 Mark Word 中，用 1bit 来存储偏向锁标志，2bit 来存储锁标志；剩余的 bit 根据锁的状态不同，可用于存储：对象 hashCode、线程 ID、指向栈中锁记录的指针、指向互斥量（重量级锁）的指针。

对象的初始状态为无锁状态，Mark Word 中存储了对象的 hashCode，偏向锁标志为 0，锁标志为 01。当一个线程第一次进入同步块时，会在对象头中记录线程 ID，并将偏向锁标志修改为 1，此时为偏向锁状态。当下次某个线程再次进入这个同步块时，会去检查 Mark Word 中的线程 ID 是不是自己的线程 ID。如果是，表明该线程已经获取了锁，该线程在进入和退出同步块时，不需要重新加锁和解锁；如果不是，则代表有另一个线程竞争这个偏向锁。这个时候，会尝试使用 CAS 操作来替换 Mark Word 里的线程 ID，这个时候分成两种情况：

- 成功：匿名偏向锁状态，之前的线程不存在了，对象头的线程 ID 替换成新的线程 ID，锁不升级
- 失败：开始进行偏向锁撤销。偏向锁撤销需要等待安全局点，即在某个时间点上没有字节码正在执行检查拥有偏向锁的线程是否存活并正在执行同步块中的代码。如果线程存在且正在执行同步块代码，则升级轻量级锁；否则，设置为匿名偏向锁状态。

JVM 会在每个线程的栈帧中创建用于记录存储锁记录的空间，称为 Displaced Mark Word。如果一个线程获得锁时，发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 中。线程会尝试使用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，则获得锁；如果失败，则当前线程会尝试自旋的方式获取锁。自旋通过循环的方式实现，需要消耗 CPU，如果线程一直获取不到锁，线程会一直处于自旋状态。自旋的次数是有上限的，JDK 采用自适应自旋的方式动态调整自旋的次数。如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，这个线程会进入阻塞状态。同时锁也会升级成重量级锁

重量级锁依赖于操作系统的互斥锁（mutex）实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但是被阻塞的线程不会消耗 CPU。当一个线程尝试获得锁时，如果锁已被占用，则该线程会被插入到阻塞队列中，线程被挂起。当有一个线程释放锁时，会从阻塞队列中挑选一个线程唤醒。synchronized 的重量级锁是非公平的。

## 2. 乐观锁 CAS 原理

CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为比较并交换，是一种无锁的原子操作，基于 CPU 提供的原子指令集。比较要更新的变量是否等于目标值，如果是，则将变量值设置为新值；如果不相等，则什么都不做，如果不相等，则会循环执行 CAS 操作，即自旋。

## 3. Java 线程的 6 种状态

- new：创建，但未启动，即没有调用 start 方法
- runnable：运行中，或者在等待 CPU 分配资源。（包含就绪和运行中）
- blocked：阻塞状态，处于阻塞态的线程正在等待锁
- waiting：等待状态，处于等待状态的线程需要被其他线程唤醒（notify、notifyAll）才能进入 runnable
- timed_waiting：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。Thread.sleep(xxx)， Object.wait(xxx)
- terminated：终止状态，线程已执行完毕

## 4. Java内存模型（JMM）

Java使用共享内存并发模型。所有线程的共享变量存在主存（堆）中，每个线程都保存了一份该线程使用到的共享变量的副本，保存在线程的本地内存中。本地内存是Java内存模型的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器等。两个线程需要通信时，线程A将本地内存中的共享变量刷新到主存中取，线程B从主存中读取线程A更新后的共享变量。

## 5. volatile 关键字

volatile 关键字可以保证可见性，但不保证原子性；可以禁止指令重排序。当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新的主存中去；同时，这个写操作会导致其他线程中的 volatile 变量缓存失效。

##

1. HashTable,HashMap,ConcurrentHashMap

- HashTable - 数组+链表实现，key 和 value 都**不能为 null**，线程安全，实现线程安全的方式是锁住整个 HashTable，效率低，ConcurrentHashMap 做了相关优化 - 初始化 size 为 11，扩容：newsize = oldsize\*2+1，size 始终为奇数，所以简单取模哈希的结果更加均匀 - 计算 index 的方法：index = (hash & 0x7FFFFFFF) % tab.length，位运算的目的是得到一个正数
- HashMap - 数组+链表实现，key 和 value 都**可以为 null**，**线程不安全** - size 初始化为 16，扩容 newsize = oldsize\*2，size 为 2 的 n 次幂 - 扩容针对整个 Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 - 插入元素后才判断该不该扩容，有可能有无效扩容（插入后，如果扩容，但没有再次插入，可能产生无效扩容） - 当 Map 中元素总数超过 Entry 数组的 75%，触发扩容操作，为了减小链表长度，元素分配更均匀 - 计算 index 的方法：index = hash & (tab.length-1) - 为 null 的键只能有一个，可以有一个或多个键对应的值为 null - 当链表大小超过阈值 8 时，链表就会被改造为树形结构（红黑树，在 Java1.8 中引入）
- HashMap 的初始值还要考虑加载因子 - 哈希冲突：若干 key 的哈希值按数组大小取模后，如果落在同一个数组下表下，将组成一条 Entry 链，对 key 的查找需要遍历真个链表的元素执行 equals（）比较 - 加载因子：为了降低哈希冲突概率，默认当 HashMap 中的键值对数达到数组大小的 75%时，会触发扩容。即当预估容量是 100 时，需要设定 100/0.75=134 的数组大小 - 空间换时间：如果希望加快 Key 查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突概率
- HashMap 和 HashTable 包含如下属性 - 容量(capacity) - 初始化容量(initial capacity) - 尺寸(size)：当前在 hash 表中记录的数量 - 负载因子(load factor)
- ConcurrentHashMap - 底层采用分段数组+链表实现，线程安全 - 通过把 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升了 N 倍，默认提升 16 倍 - ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术 - 有些方法需要跨段，比如 size()和 containsValue() - 扩容：段内扩容（段内元素超过该段对应 Entry 数组长度的 75%触发扩容，不会对整个 Map 进行扩容），插入前检测需不需扩容，避免无效扩容
- **锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据一把锁

2. 垃圾回收机制
