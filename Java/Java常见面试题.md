# Java 21新特性
**分代ZGC**、**虚拟机线程**、StringTemplate、SequencedCollection、记录模式（Record Patterns）、switch模式匹配、

## 虚拟线程
用户模式线程或纤程。虚拟线程是由JVM管理的轻量级线程，不需要任何显示分配或调度，适合I/O密集型任务，并发编程简单

# Java 常见面试题总结

## 1. synchronized 详解

### 1.1. synchronized 基本用法

用于修饰方法或代码块

- 同步方法：对象锁
- 同步代码块：对象锁，需要指定锁对象
- 同步静态方法：修饰静态方法，或执行对象为 Class 对象

### 1.2. synchronized 原理和锁升级机制

JDK1.6 以前，synchronized 是通过重量级锁实现的。JDK1.5 及其以后，引入了偏向所和轻量级锁，一个对象有 4 种状态：

- 无锁：没有对资源进行锁定，任何线程可以尝试修改和访问
- 偏向锁：只有一个线程访问同步块，加解锁几乎不需要额外的消耗
- 轻量级锁：通过自旋获取锁，占用 CPU，但响应快
- 重量级锁：阻塞线程，不消耗 CPU，但响应缓慢

每个 Java 对象都有一个对象头。非数组类型，则用 2 个位宽来存储对象头，如果是数组，则用 3 个字宽来存储对象头。32 位的 CPU，一个字宽是 32 位；64 位 CPU，一个字宽是 64 位。一个位宽用于存储对象的 hashCode 或锁信息，叫做 Mark Word；一个用于存储对象类型数据的指针；如果是数组，第三个字宽用于存储数组长度。

在 Mark Word 中，用 1bit 来存储偏向锁标志，2bit 来存储锁标志；剩余的 bit 根据锁的状态不同，可用于存储：对象 hashCode、线程 ID、指向栈中锁记录的指针、指向互斥量（重量级锁）的指针。

对象的初始状态为无锁状态，Mark Word 中存储了对象的 hashCode，偏向锁标志为 0，锁标志为 01。当一个线程第一次进入同步块时，会在对象头中记录线程 ID，并将偏向锁标志修改为 1，此时为偏向锁状态。当下次某个线程再次进入这个同步块时，会去检查 Mark Word 中的线程 ID 是不是自己的线程 ID。如果是，表明该线程已经获取了锁，该线程在进入和退出同步块时，不需要重新加锁和解锁；如果不是，则代表有另一个线程竞争这个偏向锁。这个时候，会尝试使用 CAS 操作来替换 Mark Word 里的线程 ID，这个时候分成两种情况：

- 成功：匿名偏向锁状态，之前的线程不存在了，对象头的线程 ID 替换成新的线程 ID，锁不升级
- 失败：开始进行偏向锁撤销。偏向锁撤销需要等待安全局点，即在某个时间点上没有字节码正在执行检查拥有偏向锁的线程是否存活并正在执行同步块中的代码。如果线程存在且正在执行同步块代码，则升级轻量级锁；否则，设置为匿名偏向锁状态。

JVM 会在每个线程的栈帧中创建用于记录存储锁记录的空间，称为 Displaced Mark Word。如果一个线程获得锁时，发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 中。线程会尝试使用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，则获得锁；如果失败，则当前线程会尝试自旋的方式获取锁。自旋通过循环的方式实现，需要消耗 CPU，如果线程一直获取不到锁，线程会一直处于自旋状态。自旋的次数是有上限的，JDK 采用自适应自旋的方式动态调整自旋的次数。如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，这个线程会进入阻塞状态。同时锁也会升级成重量级锁

重量级锁依赖于操作系统的互斥锁（mutex）实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但是被阻塞的线程不会消耗 CPU。当一个线程尝试获得锁时，如果锁已被占用，则该线程会被插入到阻塞队列中，线程被挂起。当有一个线程释放锁时，会从阻塞队列中挑选一个线程唤醒。synchronized 的重量级锁是非公平的。

### 1.3. synchronized 不足

- 如果临界区是只读操作，可以多个线程一起执行，但使用 synchronized，同一时间只能有一个线程执行
- synchronized 无法知道线程有没有成功获取到锁
- 使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待

## 2. 乐观锁 CAS 原理

CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为比较并交换，是一种无锁的原子操作，基于 CPU 提供的原子指令集。比较要更新的变量是否等于目标值，如果是，则将变量值设置为新值；如果不相等，则什么都不做，如果不相等，则会循环执行 CAS 操作，即自旋。

## 3. Java 线程的 6 种状态

- new：创建，但未启动，即没有调用 start 方法
- runnable：运行中，或者在等待 CPU 分配资源。（包含就绪和运行中）
- blocked：阻塞状态，处于阻塞态的线程正在等待锁
- waiting：等待状态，处于等待状态的线程需要被其他线程唤醒（notify、notifyAll）才能进入 runnable
- timed_waiting：超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。Thread.sleep(xxx)， Object.wait(xxx)
- terminated：终止状态，线程已执行完毕

## 4. Java 内存模型（JMM）

Java 使用共享内存并发模型。所有线程的共享变量存在主存（堆）中，每个线程都保存了一份该线程使用到的共享变量的副本，保存在线程的本地内存中。本地内存是 Java 内存模型的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器等。两个线程需要通信时，线程 A 将本地内存中的共享变量刷新到主存中取，线程 B 从主存中读取线程 A 更新后的共享变量。

## 5. volatile 关键字

volatile 关键字可以保证可见性，但不保证原子性；可以禁止指令重排序。当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新的主存中去；同时，这个写操作会导致其他线程中的 volatile 变量缓存失效。

## 6. 锁分类和JUC
- 乐观锁和悲观锁：是否需要锁住同步的资源。乐观锁认为自己试用数据的时候，不会有别的线程修改数据，所以不会加锁；悲观锁认为自己使用数据的时候，一定会有别的线程来修改数据，所以在获取数据的时候，会先加锁。Java中的乐观锁是采用CAS算法，Java原子类的操作就是通过CAS实现的。互斥量就是典型的悲观锁。
- 自旋锁和适应性自旋锁：阻塞或唤醒一个Java线程需要操作系统切换CPU状态完成，这种状态转换耗费CPU时间较长。有很多场景中，同步资源的锁定时间很短，线程的挂起和恢复花费的时间会导致效率低下。为了让线程等待一下，可以让线程进行自旋，即循环获取直到获取成功，这样可以避免线程切换开销。当然，自旋需要占用CPU时间，如果自旋次数太多，也会导致CPU浪费。因此，自旋超过限定次数没有获得锁，就应当挂起线程。JDK会动态调整自旋的次数，如果在同一个锁对象上，自旋刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而它将允许自旋等待更长的时间。
- 可重入锁和非可重入锁：可重入锁右称为递归锁，指一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。Java中的ReentrantLock和synchronized都是可重入锁。非可重入锁，同一个线程在获取一个锁时，必需要释放这个锁后，才能再次获取这个锁，否则将阻塞。Java中的NonReentrantLock是非可重入锁。
- 公平锁和非公平锁：先请求锁的线程会先获得锁，遵守先来后到的规则，FIFO。反之，则是非公平锁。一般情况下，非公平锁能提升一定的效率。ReentrantLock支持非公平和公平两种
- 读写锁和排他锁：读写锁可以在同一个时刻允许多个线程访问，读锁允许多个线程访问，写锁只允许一个线程访问，ReentrantReadWriteLock是Java的读写锁。排他锁也叫独享锁，同一时刻只允许一个线程访问。

## 7. HashMap、HashTable、ConcurrentHashMap
HashMap、HashTable、ConcurrentHashMap是一种kev-value形式的数据结构，底层都是通过数组+链表的形式实现的
- HashMap: key和value都可以为null，**线程不安全**。当链表长度超过阈值8时，会把链表转换为红黑树；同样，如果后续删除或调整大小后，节点数小于等于6时，会转换成链表形态。
- HashTable：key和value都不能为null，线程安全，通过synchronized关键字锁住整个表，效率低。
- ConcurrentHashMap：在JDK7中，通过分段锁的形式实现。在JDK8后，使用CAS+synchronized来保证并发安全性

## 8. 线程池
线程池是一种池化的技术实现，核心思想是实现资源的复用，避免线程重复创建和销毁带来的性能开销。降低资源消耗、提高响应速度、提高线程可管理性。其核心参数：
- 核心线程数：线程池创建时初始化的线程数。当线程池中可用的线程数量小于核心线程数时，会通过创建新的线程来运行任务
- 最大线程数：线程池允许创建的最大线程数
- 任务队列：线程达到核心线程数后，会将任务存储在阻塞队列中
- 线程最大存活时间：超出核心线程数创建的线程存活的时间
- 拒绝策略：当队列已满，且线程数达到最大线程数量时，后续任务的处理策略

##

1. HashTable,HashMap,ConcurrentHashMap

- HashTable - 数组+链表实现，key 和 value 都**不能为 null**，线程安全，实现线程安全的方式是锁住整个 HashTable，效率低，ConcurrentHashMap 做了相关优化 - 初始化 size 为 11，扩容：newsize = oldsize\*2+1，size 始终为奇数，所以简单取模哈希的结果更加均匀 - 计算 index 的方法：index = (hash & 0x7FFFFFFF) % tab.length，位运算的目的是得到一个正数
- HashMap - 数组+链表实现，key 和 value 都**可以为 null**，**线程不安全** - size 初始化为 16，扩容 newsize = oldsize\*2，size 为 2 的 n 次幂 - 扩容针对整个 Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 - 插入元素后才判断该不该扩容，有可能有无效扩容（插入后，如果扩容，但没有再次插入，可能产生无效扩容） - 当 Map 中元素总数超过 Entry 数组的 75%，触发扩容操作，为了减小链表长度，元素分配更均匀 - 计算 index 的方法：index = hash & (tab.length-1) - 为 null 的键只能有一个，可以有一个或多个键对应的值为 null - 当链表大小超过阈值 8 时，链表就会被改造为树形结构（红黑树，在 Java1.8 中引入）
- HashMap 的初始值还要考虑加载因子 - 哈希冲突：若干 key 的哈希值按数组大小取模后，如果落在同一个数组下表下，将组成一条 Entry 链，对 key 的查找需要遍历真个链表的元素执行 equals（）比较 - 加载因子：为了降低哈希冲突概率，默认当 HashMap 中的键值对数达到数组大小的 75%时，会触发扩容。即当预估容量是 100 时，需要设定 100/0.75=134 的数组大小 - 空间换时间：如果希望加快 Key 查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突概率
- HashMap 和 HashTable 包含如下属性 - 容量(capacity) - 初始化容量(initial capacity) - 尺寸(size)：当前在 hash 表中记录的数量 - 负载因子(load factor)
- ConcurrentHashMap - 底层采用分段数组+链表实现，线程安全 - 通过把 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升了 N 倍，默认提升 16 倍 - ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术 - 有些方法需要跨段，比如 size()和 containsValue() - 扩容：段内扩容（段内元素超过该段对应 Entry 数组长度的 75%触发扩容，不会对整个 Map 进行扩容），插入前检测需不需扩容，避免无效扩容
- **锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据一把锁

2. 垃圾回收机制
