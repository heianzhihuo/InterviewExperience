# Java常见面试题总结

1. HashTable,HashMap,ConcurrentHashMap
- HashTable
	- 数组+链表实现，key和value都**不能为null**，线程安全，实现线程安全的方式是锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化
	- 初始化size为11，扩容：newsize = oldsize*2+1，size始终为奇数，所以简单取模哈希的结果更加均匀
	- 计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length，位运算的目的是得到一个正数
- HashMap
	- 数组+链表实现，key和value都**可以为null**，**线程不安全**
	- size初始化为16，扩容newsize = oldsize*2，size为2的n次幂
	- 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
	- 插入元素后才判断该不该扩容，有可能有无效扩容（插入后，如果扩容，但没有再次插入，可能产生无效扩容）
	- 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减小链表长度，元素分配更均匀
	- 计算index的方法：index = hash & (tab.length-1)
	- 为null的键只能有一个，可以有一个或多个键对应的值为null
	- 当链表大小超过阈值8时，链表就会被改造为树形结构（红黑树，在Java1.8中引入）
- HashMap的初始值还要考虑加载因子
	- 哈希冲突：若干key的哈希值按数组大小取模后，如果落在同一个数组下表下，将组成一条Entry链，对key的查找需要遍历真个链表的元素执行equals（）比较
	- 加载因子：为了降低哈希冲突概率，默认当HashMap中的键值对数达到数组大小的75%时，会触发扩容。即当预估容量是100时，需要设定100/0.75=134的数组大小
	- 空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突概率
- HashMap和HashTable包含如下属性
	- 容量(capacity)
	- 初始化容量(initial capacity)
	- 尺寸(size)：当前在hash表中记录的数量
	- 负载因子(load factor)
- ConcurrentHashMap
	- 底层采用分段数组+链表实现，线程安全
	- 通过把Map分为N个Segment，可以提供相同的线程安全，但是效率提升了N倍，默认提升16倍
	- ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
	- 有些方法需要跨段，比如size()和containsValue()
	- 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需扩容，避免无效扩容
- **锁分段技术**：首先将数据分成一段一段的存储，然后给每一段数据一把锁

2. 垃圾回收机制
3. synchronized详解
3.1. 基本用法
   - 对象锁：包括方法锁(同步方法，默认锁定对象this)、同步代码块(指定锁对象)
   - 类锁：修饰静态方法（同步静态方法）或指定锁对象为Class对象

3.2. 四种状态及锁升级
JDK1.6以前，synchronized是通过重量级锁实现的。JDK1.6及其以后，引入了偏向锁和轻量级锁，一个对象有四种状态：
- 无锁状态：没有对资源进行锁定，任何线程都可以尝试修改和访问
- 偏向锁状态：只有一个线程访问同步块，加解锁不需要额外的消耗
- 轻量级锁状态：通过自旋获取锁，占用CPU，但是响应快
- 重量级锁状态：阻塞线程，不消耗CPU，响应时间缓慢
锁的级别会随着竞争情况逐渐升级。重量级锁发生在STW阶段，降级对象为VMThread访问，而没有其他线程访问。
Java对象有一个对象头，对象头的Mark World存储了对象的锁信息，1bit表示是否偏向锁，2bit为锁标志位。剩下的位，用于存储线程ID、或指向栈中锁记录的指针、指向互斥量（重量级锁）的指针。
初始状态为无锁状态，一个线程第一次进入同步块时，会在对象头中记录线程ID。
当下次某个线程进入这个同步块时，会去检查锁的线程ID是不是自己的线程ID，如果是，则表明该线程已经获得锁了；如果不是，则尝试CAS替换换对象头的线程ID，这时有两种情况：
- 成功：之前的线程不存在了，对象头的线程ID替换成新的线程ID，锁不升级
- 失败：设置锁标志位为00和和偏向所标志位为0，升级为轻量级的锁。
在轻量级锁状态下，线程会尝试使用自旋来获取锁。JDK采用适应性自旋方式调整线程自旋次数，当自旋到一定程度时，这个线程会阻塞，升级成重量级锁。

     
